import lab
import std
import cstd
import "./submod2/build.lab" as submod2
import "./submod3/build.lab" as submod3
import "@cstd/build.lab" as cstdMod
import "@std/build.lab" as stdMod
import "@core/build.lab" as coreMod
import "@json/build.lab" as jsonMod
import "@atomic/build.lab" as atomicMod
import "@fs/build.lab" as fsMod
import "@net/build.lab" as netMod
import "@docgen/build.lab" as docgenMod
import "@test/build.lab" as testMod
import "@test_env/build.lab" as testEnvMod
import "./libs/html/build.lab" as htmlTestMod
import "./libs/css/build.lab" as cssTestMod
import "./libs/js/build.lab" as jsTestMod
import "./libs/md/build.lab" as mdTestMod
import "./libs/runner/build.lab" as testLibsRunner

func build_dir_path(ctx : *BuildContext, path : &std::string_view) : std::string {
    const new_path = std::string(ctx.build_path());
    new_path.append('/')
    new_path.append_view(path);
    return new_path;
}

func gen_ir(ctx : *BuildContext, exe_name : &std::string_view, module : *mut Module) {
    module.setLlvmIrPath(ctx.build_llvm_ir_path(exe_name, module.getScopeName(), module.getName()).to_view())
    printf("module : %s, llvm ir : %s\n", module.getName().data(), module.getLlvmIrPath().data());
}

func gen_asm(ctx : *BuildContext, exe_name : &std::string_view, module : *mut Module) {
    module.setAsmPath(ctx.build_asm_path(exe_name, module.getScopeName(), module.getName()).to_view())
    printf("module : %s, asm : %s\n", module.getName().data(), module.getAsmPath().data());
}

func gen_bc(ctx : *BuildContext, exe_name : &std::string_view, module : *mut Module) {
    module.setBitcodePath(ctx.build_bitcode_path(exe_name, module.getScopeName(), module.getName()).to_view())
    printf("module : %s, bitcode : %s\n", module.getName().data(), module.getBitcodePath().data());
}

struct JobAndContext {
    var ctx : *mut AppBuildContext
    var job : *mut LabJob
}

var jc : JobAndContext

var do_llvm_ir = true;
var do_asm = false;
var do_bc = true;
var do_to_ch = true;

func get_main_module(ctx : *mut AppBuildContext, job : *mut LabJob) : *mut Module {

    // setting the environment testing for the given job
    // this sets def.test to true
    ctx.set_environment_testing(job, true)

    const zero_deps_arr : []*mut Module = []
    const zero_deps = std::span<*mut Module>(zero_deps_arr, 0)

    const exe_name = std::string_view("chemical-tests");
    const ext_c_path = lab::rel_path_to("ext/file.c");
    printf("ext_c_file path is %s\n", ext_c_path.data())
    const ext_module = ctx.c_file_module(std::string_view(""), std::string_view("ext_c"), std::string_view(ext_c_path), zero_deps)
    const ext_cpp_path = lab::rel_path_to("ext/file2.cpp")
    const ext_cpp_module = ctx.cpp_file_module(std::string_view(""), std::string_view("ext_cpp"), std::string_view(ext_cpp_path), zero_deps)

    const submod_path = lab::rel_path_to("submod")
    const submod = ctx.new_module(std::string_view(""), std::string_view("submod"), zero_deps)
    ctx.add_path(submod, std::string_view(submod_path))

    // the std module
    var cstd_module = cstdMod.build(ctx, job)

    // the std module
    var std_module = stdMod.build(ctx, job)

    // the core module
    var core_module = coreMod.build(ctx, job)

    // the json module
    var json_module = jsonMod.build(ctx, job)

    // build imported submod2 module, with it's own build method
    const submod2_module = submod2.build(ctx, job);

    // submod 3 module built
    const submod3_module = submod3.build(ctx, job)

    // the test module will be built
    const test_module = testMod.build(ctx, job)

    // the test environment is provided by this module
    const test_env_module = testEnvMod.build(ctx, job)

    // the atomic module provides atomic
    const atomic_module = atomicMod.build(ctx, job)

    // the fs module
    const fs_module = fsMod.build(ctx, job)

    // the net module
    const net_module = netMod.build(ctx, job)

    // the docgen module
    const docgen_module = docgenMod.build(ctx, job)

    // currently the last dependency becomes null if we don't take it out like this
    const dependencies = [ ext_module, ext_cpp_module, submod, submod2_module, submod3_module, std_module, core_module, json_module, atomic_module, fs_module, net_module, docgen_module, test_env_module, test_module ]
    const main_mod_path = lab::rel_path_to("src");
    const module = ctx.chemical_dir_module(std::string_view(""), std::string_view("main"), std::string_view(main_mod_path), dependencies);

    // adding a remote module
    ctx.fetch_mod_dependency(job, module, ImportRepo{
        from : "github.com/chemicallang/example",
        version : "v1.0",
        symbols : std::span<ImportSymbol>(),
        location : intrinsics::get_raw_location()
    })

    if(do_llvm_ir) {
        do_llvm_ir = false;
        gen_ir(ctx, exe_name, submod)
        gen_ir(ctx, exe_name, submod2_module)
        gen_ir(ctx, exe_name, cstd_module);
        gen_ir(ctx, exe_name, core_module);
        gen_ir(ctx, exe_name, std_module);
        gen_ir(ctx, exe_name, module);
        gen_ir(ctx, exe_name, json_module);
        gen_ir(ctx, exe_name, test_module);
        gen_ir(ctx, exe_name, test_env_module);
    }

    if(do_asm) {
        do_asm = false;
        // TODO asm generation is failing because of error in the submod
        //     error: <unknown>:0: symbol 'extern_imported_sum' is already defined
        gen_asm(ctx, exe_name, submod)
        gen_asm(ctx, exe_name, core_module);
        gen_asm(ctx, exe_name, std_module);
        gen_asm(ctx, exe_name, module);
    }

    if(do_bc) {
        do_bc = false;
        gen_bc(ctx, exe_name, submod)
        gen_bc(ctx, exe_name, core_module);
        gen_bc(ctx, exe_name, std_module);
        gen_bc(ctx, exe_name, module);
    }

    return module;

}

func run_test_lib_exe(ctx : *mut AppBuildContext, which : &std::string_view) {
    const exe_name = std::string_view("chemical-libs-tests");
    const exe_job = ctx.build_exe(exe_name)
    ctx.set_environment_testing(exe_job, true)
    switch(fnv1_hash_view(which)) {
        comptime_fnv1_hash("html") => {
            ctx.add_module(exe_job, htmlTestMod.build(ctx, exe_job))
        }
        comptime_fnv1_hash("css") => {
            ctx.add_module(exe_job, cssTestMod.build(ctx, exe_job))
        }
        comptime_fnv1_hash("js") => {
            ctx.add_module(exe_job, jsTestMod.build(ctx, exe_job))
        }
        comptime_fnv1_hash("md") => {
            ctx.add_module(exe_job, mdTestMod.build(ctx, exe_job))
        }
        default => {
            ctx.add_module(exe_job, htmlTestMod.build(ctx, exe_job))
            ctx.add_module(exe_job, cssTestMod.build(ctx, exe_job))
            ctx.add_module(exe_job, jsTestMod.build(ctx, exe_job))
            ctx.add_module(exe_job, mdTestMod.build(ctx, exe_job))
        }
    }
    ctx.add_module(exe_job, testLibsRunner.build(ctx, exe_job))
    jc.ctx = ctx;
    jc.job = exe_job;
    ctx.on_finished((data : *void) => {
        const jx = data as *mut JobAndContext
        if(jx.job.getStatus() == LabJobStatus.Success) {
            jx.ctx.launch_executable(jx.job.getAbsPath(), true);
        }
    }, &jc);
}

func build(ctx : *mut AppBuildContext) {

    if(ctx.has_arg(std::string_view("test-libs"))) {
        run_test_lib_exe(ctx, std::string_view("all"))
        return;
    } else if(ctx.has_arg(std::string_view("test-html"))) {
        run_test_lib_exe(ctx, std::string_view("html"))
        return;
    } else if(ctx.has_arg(std::string_view("test-css"))) {
        run_test_lib_exe(ctx, std::string_view("css"))
        return;
    } else if(ctx.has_arg(std::string_view("test-js"))) {
        run_test_lib_exe(ctx, std::string_view("js"))
        return;
    }

    const debug = true;
    if(debug) {
        const curr_path_str = std::string(intrinsics::get_current_file_path());
        printf("[build.lab] current file path : %s\n", curr_path_str.data());
        const curr_dir_path = lab::curr_dir();
        printf("[build.lab] current dir path : %s\n", curr_dir_path.data());
        const interested_path = lab::rel_path_to("ext/file.c");
        printf("[build.lab] interested relative path : %s\n", interested_path.data());
    }

    const compiler_version = intrinsics::version();
    printf("Compiler Version = %s\n", compiler_version);
    const str_arg = std::string_view("hello");
    if(ctx.has_arg(str_arg)) {
        const said = std::string(ctx.get_arg(str_arg));
        printf("WOW : Hello World I guess, you said %s \n", said.data());
    }
    const minimal_arg = std::string_view("minimal");
    const is_minimal = ctx.has_arg(minimal_arg)
    if(is_minimal) {
        printf("Minimal Build Detected\n");
    }

    const zero_deps_arr : []*mut Module = []
    const zero_deps = std::span<*mut Module>(zero_deps_arr, 0)

    const headers_path = build_dir_path(ctx, std::string_view("headers.ch"));
    if(intrinsics::is_clang()) {
        // const empty_module = ctx.files_module(std::string_view(""), std::string_view("headers"), null, 0, []);
        // TODO include headers call wasn't working on linux
        //ctx.include_headers(empty_module, {
        //    std::string("stdio.h"),
        //    std::string("stdlib.h")
        //});
        //ctx.translate_to_chemical(empty_module, headers_path);
    }

    // cbi integration
    // const cbi_name = std::string_view("html");
    // var html_path = ctx.resolve_import_path(std::string_view(""), std::string_view("@html/"))
    // if(html_path.error.empty()) {
    //     printf("resolved html path to be: %s\n", html_path.path.data());
    // } else {
    //     printf("detected an error when resolving the html path: %s\n", html_path.error.data());
    //     html_path.path = lab::rel_path_to("../libs/html");
    // }
    // const entry_mod = ctx.chemical_dir_module(std::string_view(""), std::string_view("html"), std::string_view(html_path.path), {});
    // ctx.build_cbi(&cbi_name, entry_mod, { entry_mod });

    do_to_ch = intrinsics::is_clang();

    const do_c = false;
    var do_dyn_lib = !is_minimal;
    const do_one_job = false;

    if(do_c) {
        const output_dir = build_dir_path(ctx, std::string_view("ToCJob.dir/output.c"));
        const job = ctx.translate_to_c(std::string_view("ToCJob"), output_dir.to_view())
        ctx.add_module(job, get_main_module(ctx, job))
    }

    const definition = std::string_view("CHECK_DEF")
    const exe_name = std::string_view("chemical-tests");

    if(do_dyn_lib) {
        const job = ctx.build_dynamic_lib(exe_name);
        ctx.add_module(job, get_main_module(ctx, job))
        ctx.define(job, definition);
        if(do_one_job) {
            return;
        }
    }

    // lets run the jit executable
    // const jit_job = ctx.run_jit_exe(exe_name);
    // ctx.add_module(jit_job, get_main_module(ctx, jit_job))

    const exe_job = ctx.build_exe(exe_name)
    ctx.add_module(exe_job, get_main_module(ctx, exe_job))

    ctx.define(exe_job, definition);
    jc.ctx = ctx;
    jc.job = exe_job;
    ctx.on_finished((data : *void) => {
        const jx = data as *mut JobAndContext
        if(jx.job.getStatus() == LabJobStatus.Success) {
            jx.ctx.launch_executable(jx.job.getAbsPath(), true);
        }
    }, &jc);

    // should be done at end, when directory for ext_module exists
    if(do_to_ch) {
        const ext_c_path = lab::rel_path_to("ext/file.c");
        const ext_module = ctx.c_file_module(std::string_view(""), std::string_view("ext_c"), std::string_view(ext_c_path), zero_deps)
        const output_file = ctx.build_mod_file_path(exe_name, ext_module.getScopeName(), ext_module.getName(), std::string_view("output.ch"));
        const input_file = lab::rel_path_to("ext/file.c")
        ctx.translate_file_to_chemical(input_file.to_view(), output_file.to_view());
    }

}