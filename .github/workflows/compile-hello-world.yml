name: Test Latest Release Assets

on:
  workflow_dispatch:

jobs:
  test-release:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            asset: linux-x86-64-tcc.zip
            chemical_executable: chemical
            binary_name: main
          - os: ubuntu-latest
            asset: linux-x86-64.zip
            chemical_executable: chemical
            binary_name: main
          - os: windows-latest
            asset: windows-x64-tcc.zip
            chemical_executable: chemical.exe
            binary_name: main.exe
          - os: windows-latest
            asset: windows-x64.zip
            chemical_executable: chemical.exe
            binary_name: main.exe
    runs-on: ${{ matrix.os }}
    steps:
      - name: Create main.ch source file (Linux)
        if: runner.os != 'Windows'
        run: |
          echo "public func printf(format : *char, _ : any...)" > main.ch
          echo "public func main() : int {" >> main.ch
          echo "    printf(\"hello world\")" >> main.ch
          echo "    return 0;" >> main.ch
          echo "}" >> main.ch
        shell: bash

      - name: Create main.ch source file (Windows)
        if: runner.os == 'Windows'
        run: |
          # Only create main.ch if it doesn't already exist
          if (!(Test-Path -Path main.ch)) {
            Set-Content -Path main.ch -Value @(
              'public func printf(format : *char, _ : any...)',
              'public func main() : int {',
              '    printf("hello world")',
              '    return 0;',
              '}'
            )
          }
        shell: pwsh

      - name: Download release asset (Linux)
        if: runner.os != 'Windows'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching release information (including pre-releases)..."
          releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases")
          ASSET_URL=$(echo "$releases" | jq -r '[.[] | select(.assets | map(.name) | index("${{ matrix.asset }}"))] | .[0].assets[] | select(.name=="${{ matrix.asset }}") | .browser_download_url')
          if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" = "null" ]; then
            echo "Error: Asset ${{ matrix.asset }} not found in any release."
            exit 1
          fi
          echo "Downloading asset from $ASSET_URL"
          curl -L -o asset.zip "$ASSET_URL"
        shell: bash

      - name: Download release asset (Windows)
        if: runner.os == 'Windows'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "Fetching release information (including pre-releases)..."
          $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/${env:GITHUB_REPOSITORY}/releases" -Headers @{ Authorization = "token $env:GITHUB_TOKEN" }
          $assetName = "${{ matrix.asset }}"
          $release = $releases | Where-Object { $_.assets -and ($_.assets | Where-Object { $_.name -eq $assetName }) } | Select-Object -First 1
          if (-not $release) {
            Write-Error "Error: Asset $assetName not found in any release."
            exit 1
          }
          $asset = $release.assets | Where-Object { $_.name -eq $assetName }
          if (-not $asset) {
            Write-Error "Error: Asset $assetName not found in the selected release."
            exit 1
          }
          Write-Host "Downloading asset from $($asset.browser_download_url)"
          Invoke-WebRequest -Uri $asset.browser_download_url -OutFile asset.zip
        shell: pwsh

      - name: Extract asset (Linux)
        if: runner.os != 'Windows'
        run: |
          unzip -o -q asset.zip || true
        shell: bash

      - name: Extract asset (Windows)
        if: runner.os == 'Windows'
        run: |
          Expand-Archive -Path asset.zip -DestinationPath .
        shell: pwsh

      - name: Compile source code (Linux)
        if: runner.os != 'Windows'
        run: |
          # Determine release root: if there is exactly one directory at top level, use it.
          release_root="."
          count=$(find . -maxdepth 1 -type d ! -path "." | wc -l)
          if [ "$count" -eq 1 ]; then
            release_root=$(find . -maxdepth 1 -type d ! -path "." | head -n 1)
          fi
          echo "Using release root: $release_root"
          # Copy main.ch if not already present.
          if [ ! -f "$release_root/main.ch" ]; then
            cp main.ch "$release_root/"
          fi
          pushd "$release_root"
          # If libtcc.so isnâ€™t in the current directory, try to find its folder and add it to LD_LIBRARY_PATH.
          libdir=$(find . -type f -name "libtcc.so" -exec dirname {} \; | head -n 1)
          if [ -n "$libdir" ]; then
            echo "Found libtcc.so in: $libdir"
            export LD_LIBRARY_PATH="$libdir:$LD_LIBRARY_PATH"
          else
            echo "Warning: libtcc.so not found by search."
          fi
          ./${{ matrix.chemical_executable }} main.ch -o ${{ matrix.binary_name }} -v
          popd
        shell: bash

      - name: Compile source code (Windows)
        if: runner.os == 'Windows'
        run: |
          $releaseRoot = "."
          $dirs = Get-ChildItem -Directory -Path .
          if ($dirs.Count -eq 1) {
            $releaseRoot = $dirs[0].FullName
          }
          Write-Host "Using release root: $releaseRoot"
          # Copy main.ch only if it doesn't already exist there.
          if (-not (Test-Path -Path "$releaseRoot\main.ch")) {
            Copy-Item -Path main.ch -Destination $releaseRoot
          }
          Push-Location $releaseRoot
          .\${{ matrix.chemical_executable }} main.ch -o ${{ matrix.binary_name }} -v
          Pop-Location
        shell: pwsh

      - name: Run compiled program and capture output (Linux)
        if: runner.os != 'Windows'
        run: |
          release_root="."
          count=$(find . -maxdepth 1 -type d ! -path "." | wc -l)
          if [ "$count" -eq 1 ]; then
            release_root=$(find . -maxdepth 1 -type d ! -path "." | head -n 1)
          fi
          echo "Using release root: $release_root"
          pushd "$release_root"
          # Set LD_LIBRARY_PATH if needed (as above)
          libdir=$(find . -type f -name "libtcc.so" -exec dirname {} \; | head -n 1)
          if [ -n "$libdir" ]; then
            export LD_LIBRARY_PATH="$libdir:$LD_LIBRARY_PATH"
          fi
          ./${{ matrix.binary_name }} | tee output.txt
          popd
          cp "$release_root/output.txt" .
        shell: bash

      - name: Run compiled program and capture output (Windows)
        if: runner.os == 'Windows'
        run: |
          $releaseRoot = "."
          $dirs = Get-ChildItem -Directory -Path .
          if ($dirs.Count -eq 1) {
            $releaseRoot = $dirs[0].FullName
          }
          Write-Host "Using release root: $releaseRoot"
          Push-Location $releaseRoot
          .\${{ matrix.binary_name }} | Tee-Object -FilePath output.txt
          Pop-Location
          Copy-Item -Path "$releaseRoot\output.txt" -Destination "$env:GITHUB_WORKSPACE\output.txt"
        shell: pwsh

      - name: Upload output artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.asset }}-output
          path: output.txt
